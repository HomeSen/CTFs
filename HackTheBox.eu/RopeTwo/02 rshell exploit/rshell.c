struct rshell_file {
    char *content_ptr;
    char name[200];
};

void main(void)
{
  ssize_t bytes_read;
  char buffer[200];

  initialize();
  memset(buffer,0,200);
  do {
    do {
      printf("$ ");
      bytes_read = read(0,buffer,199);
    } while (bytes_read < 2);
    buffer[bytes_read - 1] = '\0';
    process_input(buffer);
  } while( true );
}


void initialize(void)
{
  int i;
  
  setreuid(1000,1000);
  setvbuf(stdin,0x0,2,0);
  setvbuf(stdout,0x0,2,0);
  setvbuf(stderr,0x0,2,0);
  
  for (i=0; i<2; i++) {
    memset(g_file_array[i].name,0,200);
    g_file_array[i].content_ptr = NULL;
  }
  
  return;
}


void process_input(char *input)
{  
  if (strncmp(input, "ls", 2)) {
    ls_file();
  } else if (strncmp(input, "add ", 4)) {
    add_file(input + 4);
  } else if (strncmp(input, "rm ", 3)) {
    rm_file(input + 3);
  } else if (strncmp(input, "echo ", 5)) {
    puts(input + 5);
  } else if (strncmp(input, "edit ", 5)) {
	edit_file(input + 5);
  } else if (strncmp(input, "whoami", 6)) {
	puts("r4j");
  } else strncmp(input, "id", 2)) {
    puts("uid=1000(r4j) gid=1000(r4j) groups=1000(r4j)");
  }
  else {
	printf("rshell: %s: command not found\n", input);
  }
  
  return;
}


void add_file(char *name)
{
  int iVar1;
  char *content;
  int i;
  uint size;
  
  if ((g_file_array[0].content_ptr == 0x0) || (g_file_array[1].content_ptr == 0x0)) {
    i = 0;
    for (i=0; i<2; i++) {
      if (strcmp(g_file_array[i].name, name)) {
        puts("rshell: file exists");
        return;
      }
    }
    for (i=0; i<2; i++) {
      if (g_file_array[i].content_ptr == 0x0) {
        strncpy(g_file_array[i].name, name, 0xbe);
        printf("size: ");
        scanf("%u", &size);
		getchar();
        if (size > 0x70) {
		  puts("Memory Error!");
		  memset(g_file_array[i].name, 0, 200);
		} else {
          content = malloc(size);
          g_file_array[i].content_ptr = content;
		  
          if (g_file_array[i].content_ptr == 0x0) {
            exit(1);
          }
          printf("content: ");
          fgets(g_file_array[i].content_ptr, 0, stdin);
          break;
		}
      }
    }
  } else {
    puts("Memory Error!");
  }

  return;
}


void ls_file(void)
{
  int i;
  
  for (i=0; i<2; i++) {
    if (g_file_array[i].content_ptr != 0x0) {
      puts(g_file_array[i].name);
    }
  }
  
  return;
}


void rm_file(char *name)
{
  int i;
  
  for (i=0; i<2; i++) {
    if ((strcmp(name,g_file_array[i].name)) && (g_file_array[i].content_ptr != 0x0)) {
      memset(g_file_array[i].name,0,200);
      free(g_file_array[i].content_ptr);
      g_file_array[i].content_ptr = NULL;
	  
      return;
    }
  }
  
  printf("rm: cannot remove \'%s\': No such file or directory\n",name);
  return;
}


void edit_file(char *name)
{
  uint size;
  int i;
  char *buffer;
  
  i = 0;
  for (i=0; i<2; i++) {
    if ((strcmp(name,g_file_array[i].name)) && (g_file_array[i].content_ptr != NULL)) {
      size = 0;
      printf("size: ");
      scanf("%u",&size);
      getchar();
      if (size > 0x70) {
        puts("Memory Error!");
		return;
      }
	  
      buffer = realloc(g_file_array[i].content_ptr, size);
      if (buffer == NULL) {
        puts("Error");
      }
      else {
        g_file_array[i].content_ptr = buffer;
        printf("content: ");
        read(0, g_file_array[i].content_ptr, size);
      }
	  
      return;
    }
  }
  
  puts("rshell: No such file or directory");
  return;
}


