
struct miscdevice {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

struct ralloc_item {
	long size;
	void *data;
};

miscdevice misc;
ralloc_item arr[32];


undefined8 rope2_init(void)
{
	__fentry__();
	misc_register(&misc);
	return 0;
}


void rope2_exit(void)
{
	__fentry__();
	misc_deregister(&misc);
	return;
}


long rope2_ioctl(FILE *f, uint cmd, ulong arg)
{
	void *__dest;
	long result;
	void *ptr;
	ulong size;
	ulong idx;
	void *ptrUserSpace;
	
	__fentry__();
	mutex_lock(lock);
	
	// unsigned long copy_from_user (void *to, const void __user *from, unsigned long n);
	_copy_from_user(&idx, arg, 0x18);
	
	result = -1;
	switch (cmd) {			
		case 0x1000:	// create buffer
			if ((size < 0x401) && (idx < 0x20)) {
				if (arr[idx].data == 0x0) {
					// void * __kmalloc (size_t size, int flags);
					ptr = __kmalloc(size, GFP_KERNEL);
					arr[idx].data = ptr;
					if (ptr != 0x0) {
						arr[idx].size = size + 0x20;
						result = 0;
					}
				}
			}
			break;
			
		case 0x1001:	// delete buffer
			if ((idx < 0x20) && (arr[idx].data != 0)) {
				kfree(arr[idx].data);
				arr[idx].data = 0;
				result = 0;
			}
			break;
		
		case 0x1002:	// write to array
			if (idx < 0x20) {
				__dest = arr[idx].data;
				ptr = ptrUserSpace;
				if ((arr[idx].data != 0x0) && ((size & 0xffffffff) <= arr[idx].size)) {
					if ((ptrUserSpace & 0xffff000000000000) == 0) {
						memcpy(__dest, ptr, size & 0xffffffff);
						result = 0;
					}
				}
			}
			break;
		
		case 0x1003:	// read from array
			if (idx < 0x20) {
				__dest = ptrUserSpace;
				ptr = arr[idx].data;
				if ((ptr != 0x0) && ((size & 0xffffffff) <= arr[idx].size)) {
					if ((ptrUserSpace & 0xffff000000000000) == 0) {
						memcpy(__dest, ptr, size & 0xffffffff);
						result = 0;
					}
				}
			}
			break;
	}
	mutex_unlock(lock);
	
	return result;
}